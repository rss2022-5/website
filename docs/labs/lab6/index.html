<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.16">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.24/dist/katex.min.css" integrity="sha384-odtC+0UGzzFL/6PNoE8rX/SPcQDXBJ+uRepguP4QkPCm2LBxH3FA3y+fKSiJ+AmM" crossorigin="anonymous"><title data-rh="true">Lab 6 - Pure Pursuit of Happyness | MIT Robotics Science and Systems Group 5 2022</title><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://rss2022-5.github.io//website/docs/labs/lab6"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Lab 6 - Pure Pursuit of Happyness | MIT Robotics Science and Systems Group 5 2022"><meta data-rh="true" name="description" content="Path Planning"><meta data-rh="true" property="og:description" content="Path Planning"><link data-rh="true" rel="icon" href="/website/img/car.ico"><link data-rh="true" rel="canonical" href="https://rss2022-5.github.io//website/docs/labs/lab6"><link data-rh="true" rel="alternate" href="https://rss2022-5.github.io//website/docs/labs/lab6" hreflang="en"><link data-rh="true" rel="alternate" href="https://rss2022-5.github.io//website/docs/labs/lab6" hreflang="x-default"><link rel="stylesheet" href="/website/assets/css/styles.961fa701.css">
<link rel="preload" href="/website/assets/js/runtime~main.05126e7d.js" as="script">
<link rel="preload" href="/website/assets/js/main.32b19255.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_ZgBM">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/website/"><div class="navbar__logo"><img src="/website/img/logo.svg" alt="Robot" class="themedImage_W2Cr themedImage--light_TfLj"><img src="/website/img/logo.svg" alt="Robot" class="themedImage_W2Cr themedImage--dark_oUvU"></div><b class="navbar__title">MIT Robotics Science and Systems Group 5 2022</b></a><a class="navbar__item navbar__link navbar__link--active" href="/website/docs/intro">Labs</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/rss2022-5" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="toggle_Pssr toggle_TdHA toggleDisabled_jDku"><div class="toggleTrack_SSoT" role="button" tabindex="-1"><div class="toggleTrackCheck_XobZ"><span class="toggleIcon_eZtF">üåú</span></div><div class="toggleTrackX_YkSC"><span class="toggleIcon_eZtF">üåû</span></div><div class="toggleTrackThumb_uRm4"></div></div><input type="checkbox" class="toggleScreenReader_JnkT" aria-label="Switch between dark and light mode (currently light mode)"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_P2Lg"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_RiI4" type="button"></button><aside class="theme-doc-sidebar-container docSidebarContainer_rKC_"><div class="sidebar_CW9Y"><nav class="menu thin-scrollbar menu_SkdO"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/website/docs/intro">Welcome!</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" href="/website/docs/labs/lab3">Lab Reports</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/website/docs/labs/lab3">Lab 3 - Perks of Being a Wallfollower</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/website/docs/labs/lab4">Lab 4</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/website/docs/labs/lab5">Lab 5 - Pocket Full of Poses</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/website/docs/labs/lab6">Lab 6 - Pure Pursuit of Happyness</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/website/docs/Presentations/lab3">Presentations</a></div></li></ul></nav></div></aside><main class="docMainContainer_TCnq"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_DM6M"><div class="docItemContainer_vinB"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Xlws" aria-label="breadcrumbs"><ul class="breadcrumbs"><li class="breadcrumbs__item"><span class="breadcrumbs__link breadcrumbsItemLink_e5ie">Lab Reports</span></li><li class="breadcrumbs__item breadcrumbs__item--active"><a class="breadcrumbs__link breadcrumbsItemLink_e5ie" href="/website/docs/labs/lab6">Lab 6 - Pure Pursuit of Happyness</a></li></ul></nav><div class="tocCollapsible_jdIR theme-doc-toc-mobile tocMobile_TmEX"><button type="button" class="clean-btn tocCollapsibleButton_Fzxq">On this page</button></div><div class="theme-doc-markdown markdown"><h1>Lab 6 - Pure Pursuit of Happyness</h1><h2 class="anchor anchorWithStickyNavbar_mojV" id="path-planning">Path Planning<a class="hash-link" href="#path-planning" title="Direct link to heading">‚Äã</a></h2><h2 class="anchor anchorWithStickyNavbar_mojV" id="introduction">Introduction<a class="hash-link" href="#introduction" title="Direct link to heading">‚Äã</a></h2><p>[Carolina]</p><p>This lab built off of our previous accomplishments in the localization lab to implement a powerful ability on our robot ‚Äì navigation. Navigating our robot in an environment involves finding a path to take through the environment and then successfully following this path to reach a goal destination. To accomplish this path-planning, we implemented two path-finding algorithms, <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>‚àó</mo></mrow><annotation encoding="application/x-tex">A*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal">A</span><span class="mord">‚àó</span></span></span></span></span> and <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>R</mi><mi>T</mi><mo>‚àó</mo></mrow><annotation encoding="application/x-tex">RRT*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.13889em">RRT</span><span class="mord">‚àó</span></span></span></span></span>, and then used the pure pursuit method for following the generated paths. Integrating the two to give our robot the capacity to create and execute paths was as simple as running both of the algorithms simultaneously. We evaluated each algorithm in simulation and then tested the combination of the algorithms on hardware, finding that our robot was able to successfully generate paths and reach a goal node in a reasonable amount of time. We found that there is room for tuning in our code, as well as a need to further refine our localization code from the previous lab to work better with pure pursuit. However, our navigation approach was overall successful, and will be greatly helpful to us in the final challenge as our robot learns to drive safely in a unique ‚Äúcity‚Äù environment.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="technical-implementation">Technical Implementation<a class="hash-link" href="#technical-implementation" title="Direct link to heading">‚Äã</a></h2><h3 class="anchor anchorWithStickyNavbar_mojV" id="a">A*<a class="hash-link" href="#a" title="Direct link to heading">‚Äã</a></h3><p>[Ishita]</p><p>Moving a robot between two points in space is a daunting task. One of the ways we approached this problem was by adapting an algorithm we‚Äôd heard of in previous classes: <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>‚àó</mo></mrow><annotation encoding="application/x-tex">A*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal">A</span><span class="mord">‚àó</span></span></span></span></span>. <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>‚àó</mo></mrow><annotation encoding="application/x-tex">A*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal">A</span><span class="mord">‚àó</span></span></span></span></span> is a graph algorithm that finds a path between two points, and optimizes the path to minimize its length. To discretize a map and turn it into a graph, we used each pixel on the map as a node as shown in Figure 1, and considered there to be edges between each node and its four neighbors. For a given point <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal" style="margin-right:0.03588em">y</span><span class="mclose">)</span></span></span></span></span> in pixel coordinates, the four neighbors were the elements of <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>‚àí</mo><mn>1</mn><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>‚àí</mo><mn>1</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{(x-1,y), (x+1,y), (x,y-1), (x,y+1) }</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">‚àí</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal" style="margin-right:0.03588em">y</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal" style="margin-right:0.03588em">y</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal" style="margin-right:0.03588em">y</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">‚àí</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal" style="margin-right:0.03588em">y</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></span> that were within the map‚Äôs bounds. The decision to not include diagonal neighbors was made to reduce computation time, and because the difference in distance between a diagonal map and one that stepped one edge in each direction was small enough to be negligible.</p><center><img src="/website/assets/images/graph-b69b97e4531ef1e44fba2e2db792cc7e.png" alt="Graph" style="height:300px"></center><p><strong>Figure 1: This diagram shows the discretization of a map into pixel squares.</strong></p><p>Our implementation keeps track of the minimum distance between the start node and every other node in a dictionary, and updates the dictionary every time a shorter path is found between the two nodes. The algorithm generates the four neighbors of the current node and adds the ones that have not yet been visited to an open set. It then treats this set as a priority queue, and uses a heuristic to determine which should be chosen next. The heuristic sums the distance between the node and its current neighbor with the linear distance between the neighbor and the goal to optimally pick which neighbors  should be explored next. This heuristic was used over alternatives such as Dubins curves because experimentation showed that linear distance worked better with discretization. After this, the node is added to a visited set to ensure that it is not revisited. In this manner, each node is visited exactly once, reducing computation time. When the algorithm chose a path that reached the goal node, this was chosen as the optimal path since the algorithm had already been optimizing at every step.</p><center><img src="/website/assets/images/rviz-aea0bba5b60e5b4bdb8195bcbb12e353.png" alt="rviz" style="height:300px"></center><p><strong>Figure 2: Sample <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>‚àó</mo></mrow><annotation encoding="application/x-tex">A*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal">A</span><span class="mord">‚àó</span></span></span></span></span> map between two points</strong></p><p>In practice, the <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>‚àó</mo></mrow><annotation encoding="application/x-tex">A*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal">A</span><span class="mord">‚àó</span></span></span></span></span> maps chosen sometimes contained very small line segments as shown in figure 2, which would make it difficult for the car to actually follow the paths. Some of these issues were addressed with creative manipulations of the map. We found that dilating the map made the robot less likely to crash into walls by giving it a margin. In addition, we eroded the map to rid it of extraneous points before converting the map into a graph and running the algorithm on it.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="rrt">RRT<a class="hash-link" href="#rrt" title="Direct link to heading">‚Äã</a></h3><p>[Tiffany]</p><p>An alternate type of path planning algorithm is a sampling based algorithm, which randomly chooses points in the map to pass through and then checks for collisions, speeding up the process by avoiding the need to generate and search through a graph of the entire map.</p><p>We chose to implement <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>R</mi><mi>T</mi><mo>‚àó</mo></mrow><annotation encoding="application/x-tex">RRT*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.13889em">RRT</span><span class="mord">‚àó</span></span></span></span></span> as our sampling based algorithm. Our implementation had several iterations as we optimized the code.  At first, we started with a simple <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>R</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">RRT</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.13889em">RRT</span></span></span></span></span> implementation: generating a random point, generating a path between that and the nearest point already in the graph, seeing if that path reaches the end, and if not, continuing to generate the tree. While this method was fast, as it stopped as soon as a path to the end was found, it also allowed for non-optimal paths. To improve this, we created what we called <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>R</mi><mi>T</mi><mo>+</mo></mrow><annotation encoding="application/x-tex">RRT+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em"></span><span class="mord mathnormal" style="margin-right:0.13889em">RRT</span><span class="mord">+</span></span></span></span></span>, which continued generating paths until we had sampled a given number of points, stored the distances of all the paths that made it to the end and chose the best from among those. Finally, we implemented <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>R</mi><mi>T</mi><mo>‚àó</mo></mrow><annotation encoding="application/x-tex">RRT*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.13889em">RRT</span><span class="mord">‚àó</span></span></span></span></span> which updated the paths as it generated points by trying to ‚Äústeal‚Äù the shortest path of previous nodes located within a box centered at the new node. This created much more optimal paths, but at the cost of speed. </p><center><img src="/website/assets/images/dubin-66f938fca93f426f6a4614c6f9c825f4.png" alt="dubin" style="height:300px"></center><p><strong>Figure 3: Examples of possible Dubins curves which guarantee optimal possible paths</strong></p><p>By changing the cost metric for distance to Dubins curves, we improved the results of our path planning algorithm. Dubins curves allow us to find the optimal path for a forward-only car by saying that the shortest path for such a car is some 3-turn combination of 3 possible directions: Left, Right, and Straight. In order to create smooth curves which were possible given the robot‚Äôs current position and robot‚Äôs movement capabilities, we used these as our cost metric in the <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>R</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">RRT</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.13889em">RRT</span></span></span></span></span> implementation. This made the path smoother and only represented paths that the car could actually take which was beneficial for pure pursuit. </p><h4 class="anchor anchorWithStickyNavbar_mojV" id="comparing-search-and-sample-algorithms">Comparing Search and Sample Algorithms<a class="hash-link" href="#comparing-search-and-sample-algorithms" title="Direct link to heading">‚Äã</a></h4><p>We chose to use the <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>R</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">RRT</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.13889em">RRT</span></span></span></span></span> algorithm as it was faster than <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>‚àó</mo></mrow><annotation encoding="application/x-tex">A*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal">A</span><span class="mord">‚àó</span></span></span></span></span> and implemented Dubins curves as the cost function, making it more practical to test with and creating only possible paths. By using Dubins curves as the cost function, the path-planning algorithm was able to incorporate the dynamics of the car and generate only paths the car would possibly be able to take. <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>R</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">RRT</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.13889em">RRT</span></span></span></span></span> works faster, in O(nlogn),  by avoiding the need to create a graph of the entire space and then subsequently search for it as <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>‚àó</mo></mrow><annotation encoding="application/x-tex">A*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal">A</span><span class="mord">‚àó</span></span></span></span></span> must, taking O(<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>4</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">4^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em"></span><span class="mord"><span class="mord">4</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span>) time. In this sense, <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>R</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">RRT</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.13889em">RRT</span></span></span></span></span> is better for large spaces like the Stata basement which would be expensive to do with <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>‚àó</mo></mrow><annotation encoding="application/x-tex">A*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal">A</span><span class="mord">‚àó</span></span></span></span></span>. Our <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>R</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">RRT</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.13889em">RRT</span></span></span></span></span> implementation avoids the need to search once the tree is created by storing parent pointers, speeding up the implementation.  While <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>‚àó</mo></mrow><annotation encoding="application/x-tex">A*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal">A</span><span class="mord">‚àó</span></span></span></span></span> generates optimal paths, <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>R</mi><mi>T</mi><mo>‚àó</mo></mrow><annotation encoding="application/x-tex">RRT*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.13889em">RRT</span><span class="mord">‚àó</span></span></span></span></span> generates optimal paths as the number of samples approaches infinity. In this case, when we strongly limit the number of samples, <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>‚àó</mo></mrow><annotation encoding="application/x-tex">A*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal">A</span><span class="mord">‚àó</span></span></span></span></span> created more optimal paths than <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>R</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">RRT</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.13889em">RRT</span></span></span></span></span>. As the number of samples increases, however, <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>R</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">RRT</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.13889em">RRT</span></span></span></span></span> becomes increasingly optimal while not taking too long to run. As a result, <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>R</mi><msup><mi>T</mi><mo mathvariant="normal" lspace="0em" rspace="0em">‚Ä≤</mo></msup><mi>s</mi></mrow><annotation encoding="application/x-tex">RRT&#x27;s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em"></span><span class="mord mathnormal" style="margin-right:0.00773em">RR</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em">T</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">‚Ä≤</span></span></span></span></span></span></span></span></span><span class="mord mathnormal">s</span></span></span></span></span> benefits outweighed the potential drawbacks of having potentially less optimal paths. </p><h3 class="anchor anchorWithStickyNavbar_mojV" id="pure-pursuit">Pure Pursuit<a class="hash-link" href="#pure-pursuit" title="Direct link to heading">‚Äã</a></h3><p>[Vedang]</p><p>The pure pursuit portion of the code combines all of the components of this project. Our pure pursuit implementation is similar to that implemented in Lab 4: a simple two step algorithm that repeats indefinitely. The first step is to determine a point to drive to and the second step is to simply  drive to the point.</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="pure-pursuit-determining-the-point">Pure Pursuit: Determining the Point<a class="hash-link" href="#pure-pursuit-determining-the-point" title="Direct link to heading">‚Äã</a></h4><p>Given a discrete trajectory, determining the point to drive to is the most challenging of the two steps. To solve this problem, we form a circle around the car, the radius being the value <code>self.lookahead</code>. The first step of the algorithm is to drive to the closest segment that intersects the lookahead circle. This value is constantly calculated throughout the robot‚Äôs motion with the use of efficient <code>numpy</code> operations. We approximate line-segments with infinite lines, and calculate the shortest distance to the given line segmentation using the point to line vector formula. This is clearly outlined in the diagram below, where arrows are represented by trajectories formed by path planning algorithms, and the dotted line represents the shortest distance.</p><center><img src="/website/assets/images/segs-66c31cb495e42e26f37c23d79b4d8d12.jpg" alt="segment" style="height:300px"></center><p><strong>Figure 4: In Pure Pursuit, the first step is to calculate the distance to all of the segments, shown by the dotted line above.</strong></p><p>Once we have picked a segment of interest, we need to find a point on the segment. This will become the segments that we will drive toward. This is calculated by solving a quadratic equation, by equating the equations of a line and a circle, which results in two solutions. We pick the solution that takes us forward on the trajectory. This math problem is generalized to the diagram that we see below.</p><center><img src="data:image/png;base64,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" alt="circle" style="height:300px"></center><p><strong>Figure 5 In Pure Pursuit, the second step is to calculate the intersections of a segment on the <code>self.lookahead</code> circle, defined by the radius <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.02778em">r</span></span></span></span></span> above. If the car were facing right, we would drive to the intersection closer to <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">p_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span></span></strong></p><p>With creative freedoms in our implementation, we include a second ‚Äúback-up‚Äù lookahead if the first one fails. This backup lookahead remains at the start of the closest segment that lies at a distance of 1.5*<code>self.lookahead</code> distance. This second lookahead point is essential for navigating dense trajectories, where the normal lookahead distance may fail. In the animation below, at the end of the trajectory, you can see that the first lookahead point, shown by the red dot, lies outside of the trajectory. The racecar can navigate to the correct finish point because it lies on the correct finish trajectory. This is how we determine the point, now we must just drive to it.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="pure-pursuit-driving-to-the-point">Pure Pursuit: Driving to the Point<a class="hash-link" href="#pure-pursuit-driving-to-the-point" title="Direct link to heading">‚Äã</a></h3><p>This last part is arguably the easiest of all. Once we have determined a point to drive we must control the steering angle. If the absolute value of the steering angle lies outside of <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.25</mn></mrow><annotation encoding="application/x-tex">0.25</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">0.25</span></span></span></span></span> radians, we decrease the velocity of the racecar by a factor of <code>1-self.steering_angle</code>. This ensures an accurate trajectory following a variety of turns. This information is best conveyed in the diagram below, which outlines the formula for the steering angle and how to drive to the point of interest. </p><center><img src="/website/assets/images/pp-3ebb628f5ffb8228588e5787dbc29e6c.png" alt="pure pur" style="height:300px"></center><p><strong>Figure 6: This figure shows how step 2 of pure pursuit works. Once a point is chosen, the steering angle is changed to the equation above in order to drive to the point.</strong></p><h2 class="anchor anchorWithStickyNavbar_mojV" id="evaluation">Evaluation<a class="hash-link" href="#evaluation" title="Direct link to heading">‚Äã</a></h2><h3 class="anchor anchorWithStickyNavbar_mojV" id="rrt-and-a-evaluation"><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>R</mi><mi>T</mi><mo>‚àó</mo></mrow><annotation encoding="application/x-tex">RRT*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.13889em">RRT</span><span class="mord">‚àó</span></span></span></span></span> and <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>‚àó</mo></mrow><annotation encoding="application/x-tex">A*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal">A</span><span class="mord">‚àó</span></span></span></span></span> Evaluation<a class="hash-link" href="#rrt-and-a-evaluation" title="Direct link to heading">‚Äã</a></h3><p>[Carolina]</p><p>To evaluate <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>R</mi><mi>T</mi><mo>‚àó</mo></mrow><annotation encoding="application/x-tex">RRT*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.13889em">RRT</span><span class="mord">‚àó</span></span></span></span></span> in simulation, we looked at the overall distance of our path, the time it took to generate the path, and the smoothness of the path. Ideally, we would generate shorter, smoother paths in less time. Smoothness is especially important because in real life, we can travel a smooth path faster than a jagged path. Our car has to slow down to make sharp turns, but can take curves at a higher speed.</p><p>We facilitated the error-logging process in this lab by creating a simple error logging script with methods to write to a file. We called these methods in our code to record the full distance of the generated path, the time it took to generate (found by subtracting <code>rospy.get_time()</code> at the start of the path generation from the time at the end), and the full trajectory of the path, which we would evaluate later.  </p><p>To run tests repeatedly using the same positions for both algorithms, we decided not to use RVIZ tools (giving it poses in the exact same position would not have been possible). Instead, we created a script based off of pose_init_pub.py, called destination_pub.py, which published a goal node directly to the robot. We first ran pose_init_pub with a position of <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0,0,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span></span> to initialize the robot, and then used <code>destination_pub.py</code> to publish one of three positions in different locations on the Stata basement map (which were found previously using RVIZ tools). Publishing a position to the robot started the path-planning algorithm, and we repeated the trial for each position.</p><p>[Quinn]</p><p><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>‚àó</mo></mrow><annotation encoding="application/x-tex">A*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal">A</span><span class="mord">‚àó</span></span></span></span></span> was evaluated the same way as <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>R</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">RRT</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.13889em">RRT</span></span></span></span></span>; we examined the length and curvature of the produced paths, as well as the time it took to compute them. The results are shown in Table 1 below.</p><center><img src="/website/assets/images/table1-46a90404aa09bbe29037cb89946f1946.png" alt="table1" style="height:300px"></center><p> <strong>Table 1: Experimental results of two path planning algorithms. Both algorithms used the same set of points</strong></p><p> We can see from the data some clear trends. Firstly, we notice that <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>R</mi><mi>T</mi><mo>‚àó</mo></mrow><annotation encoding="application/x-tex">RRT*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.13889em">RRT</span><span class="mord">‚àó</span></span></span></span></span> runs in mostly constant time, regardless of the particular point it is navigating to. This makes sense in the context of the algorithm: <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>R</mi><mi>T</mi><mo>‚àó</mo></mrow><annotation encoding="application/x-tex">RRT*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.13889em">RRT</span><span class="mord">‚àó</span></span></span></span></span> generates and processes a fixed number of points, so the process should take the same amount of time.</p><p><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>‚àó</mo></mrow><annotation encoding="application/x-tex">A*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal">A</span><span class="mord">‚àó</span></span></span></span></span>, on the other hand, has a significantly more variable runtime. With reasonable confidence, we can notice that runtime scales linearly with the final distance of the path. This also makes sense in the context of the algorithm; <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>‚àó</mo></mrow><annotation encoding="application/x-tex">A*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal">A</span><span class="mord">‚àó</span></span></span></span></span> exits as soon as it finds the optimal path to the destination point. Before then, the algorithm will have to search a number of points proportional to the path length, which will take a runtime proportional to the path length.</p><p>We now compare resultant path lengths; <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>‚àó</mo></mrow><annotation encoding="application/x-tex">A*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal">A</span><span class="mord">‚àó</span></span></span></span></span> produces shorter paths in every case. This is expected; <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>‚àó</mo></mrow><annotation encoding="application/x-tex">A*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal">A</span><span class="mord">‚àó</span></span></span></span></span> is guaranteed to produce optimal results for its cost function. <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>R</mi><mi>T</mi><mo>‚àó</mo></mrow><annotation encoding="application/x-tex">RRT*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.13889em">RRT</span><span class="mord">‚àó</span></span></span></span></span>, for comparison, is a random algorithm that does have guarantees on its runtime, but gives up its guarantees on path length. Furthermore, while not documented here, <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>R</mi><mi>T</mi><mo>‚àó</mo></mrow><annotation encoding="application/x-tex">RRT*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.13889em">RRT</span><span class="mord">‚àó</span></span></span></span></span> will generate paths of different lengths every time it is run. It is not deterministic. In the cases above, <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>‚àó</mo></mrow><annotation encoding="application/x-tex">A*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal">A</span><span class="mord">‚àó</span></span></span></span></span> produced paths that were on average 10% shorter than <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>R</mi><mi>T</mi><mo>‚àó</mo></mrow><annotation encoding="application/x-tex">RRT*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.13889em">RRT</span><span class="mord">‚àó</span></span></span></span></span>.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="pure-pursuit-evaluation">Pure Pursuit Evaluation<a class="hash-link" href="#pure-pursuit-evaluation" title="Direct link to heading">‚Äã</a></h3><p>[Ishita]</p><p>The goal of pure pursuit was to help the robot follow the path that it received from the path planning algorithm. Thus, to evaluate this , we recorded the absolute error of the robot‚Äôs path (current position - intended position on the map). We recorded error as the robot ran three different paths, and also tested for three different speeds. For the most part, the error recorded is low, indicating that the pure pursuit worked well. However, we see large error occurring when the robot makes turns at high speeds, indicated by the spikes in the graph below. This error is caused by localization, because our robot goes off its predicted position, and the change is too fast for localization code to work well. After much experimentation, we‚Äôve determined that it seems to be our localization code that is the issue. In addition, with the true odometry location, the plots should turn out similarly to what the low speed plots looked like.
The three graphs from our resulting data are shown below.</p><p><strong>  0.5 m/s</strong></p><center><img src="/website/assets/images/plot1-ef4db2ca2612f4d31cb17b62c65b41b2.png" alt="plot1" style="height:300px"></center><p><strong>  1.0 m/s</strong></p><center><img src="/website/assets/images/plot2-b4cb01d5d0350a2feb978fac9e108795.png" alt="plot2" style="height:300px"></center><p><strong>  2.0 m/s</strong></p><center><img src="/website/assets/images/plot3-d875618424f791a60be1899554b169ef.png" alt="plot3" style="height:300px"></center><p><strong>Figures 7,8,9: Graphs of pure pursuit error over time. Notice the significant jump in error when the car was turning. In addition, note that the y-axis for the first graph is much different than the other two.</strong></p><h3 class="anchor anchorWithStickyNavbar_mojV" id="hardware-performance-evaluation">Hardware Performance Evaluation<a class="hash-link" href="#hardware-performance-evaluation" title="Direct link to heading">‚Äã</a></h3><p>[Carolina ]</p><p>As a final step in this project, we evaluated the performance of our path-finding and path-following algorithms together on the physical robot. To integrate the code, we simply ran the launch files for <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>R</mi><mi>T</mi><mo>‚àó</mo></mrow><annotation encoding="application/x-tex">RRT*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.13889em">RRT</span><span class="mord">‚àó</span></span></span></span></span> (since it showed better performance than <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>‚àó</mo></mrow><annotation encoding="application/x-tex">A*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal">A</span><span class="mord">‚àó</span></span></span></span></span> in simulation) and pure pursuit simultaneously, and published points to the robot using destination_pub.py. We ran the robot using the same goal node, but we changed the speed for each trial (0.5, 1 and 2 m/s). All of the types of error logged during the simulation trials for path-finding and path-following were logged during these trials as well ‚Äì we recorded the total distance of each path, the time it took the robot to complete the path, and the absolute error over time.</p><p><strong>0.5 m/s</strong></p><center><img src="/website/assets/images/plot4-0786e22a8272f01a4c7d63bfaee21505.png" alt="plot4" style="height:300px"></center><p><strong>1.0 m/s</strong></p><center><img src="/website/assets/images/plot5-ad608d686a372c5bbb82af773b563033.png" alt="plot5" style="height:300px"></center><p><strong>2.0 m/s</strong></p><center><img src="/website/assets/images/plot6-bdf3960030313605f119320aa41dcdb0.png" alt="plot6" style="height:300px"></center><p><strong>Figures 10,11,12: Graphs of the absolute error (car position - trajectory position) over time for trials at 0.5, 1.0 and 2.0 m/s. The first two plots also indicate a shaded error region, as multiple trials were conducted at these speeds.</strong></p><p><strong>Time and Path Length in Hardware Evaluation at Different Speeds</strong></p><center><img src="/website/assets/images/table2-a4f6d922a2d7b397be5a80b0ca7e5447.png" alt="table2" style="height:300px"></center><p>Looking at our absolute error plots, we can see that our robot‚Äôs error is fairly low at a speed of <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.5</mn></mrow><annotation encoding="application/x-tex">0.5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">0.5</span></span></span></span></span>m/s, ranging from <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>‚àí</mo><mn>12</mn></mrow><annotation encoding="application/x-tex">0-12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">‚àí</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">12</span></span></span></span></span> cm with an average of about <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">6</span></span></span></span></span> cm. However, as we increase the speed, our error increases, peaking at <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>14</mn></mrow><annotation encoding="application/x-tex">14</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">14</span></span></span></span></span>cm and <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>35</mn></mrow><annotation encoding="application/x-tex">35</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">35</span></span></span></span></span>cm at one point at a speed of <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">2</span></span></span></span></span>m/s. In terms of speed, we can see that our robot clearly runs similar-length paths slower at <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.5</mn></mrow><annotation encoding="application/x-tex">0.5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">0.5</span></span></span></span></span> m/s ‚Äì dividing the path distance by the run time yields about <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.499</mn></mrow><annotation encoding="application/x-tex">0.499</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">0.499</span></span></span></span></span> m/s. However, there is not a significant difference (only about 7 seconds) between the car running a path essentially the same length at <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">1</span></span></span></span></span>m/s and <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">2</span></span></span></span></span>m/s. If we look at the distance over time for both trials, we see the average speed of the car was <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.65</mn></mrow><annotation encoding="application/x-tex">0.65</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">0.65</span></span></span></span></span> m/s and <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.78</mn></mrow><annotation encoding="application/x-tex">0.78</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">0.78</span></span></span></span></span> m/s, which are <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>65</mn></mrow><annotation encoding="application/x-tex">65%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">65</span></span></span></span></span> and <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>39</mn></mrow><annotation encoding="application/x-tex">39%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">39</span></span></span></span></span> of the set speeds, respectively. This reduction in speed is due to the curvature of this path ‚Äì in our pure pursuit code, we adjust our speed to handle turns safely, and so even with a higher given speed, there is a limit to how fast the robot can be at any point due to the curvature of our path.  However, as established from individually evaluated pure pursuit and <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>R</mi><mi>T</mi><mo>‚àó</mo></mrow><annotation encoding="application/x-tex">RRT*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.13889em">RRT</span><span class="mord">‚àó</span></span></span></span></span>, there is room for improvement in both algorithms, as well as in our localization code, that would lead to a better combined result and would enable us to reach higher speeds.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="conclusion">Conclusion<a class="hash-link" href="#conclusion" title="Direct link to heading">‚Äã</a></h2><p>[Quinn B ]</p><p>This lab represents the most complex combination of systems we have yet implemented. We first implemented two solutions to the problem of path planning. We found paths with a search based algorithm, <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>‚àó</mo></mrow><annotation encoding="application/x-tex">A*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal">A</span><span class="mord">‚àó</span></span></span></span></span>, and a random sampling based algorithm, <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>R</mi><mi>T</mi><mo>‚àó</mo></mrow><annotation encoding="application/x-tex">RRT*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.13889em">RRT</span><span class="mord">‚àó</span></span></span></span></span>. Because of the significantly better runtime, we chose to use <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>R</mi><mi>T</mi><mo>‚àó</mo></mrow><annotation encoding="application/x-tex">RRT*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.13889em">RRT</span><span class="mord">‚àó</span></span></span></span></span> for future path planning. Newly armed with both path planning and localization algorithms, we could now implement a pure pursuit controller, to drive the car along <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>R</mi><mi>T</mi><mo>‚àó</mo><mtext>‚Äô</mtext><mi>s</mi></mrow><annotation encoding="application/x-tex">RRT*‚Äôs</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.13889em">RRT</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">‚àó</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord">‚Äô</span><span class="mord mathnormal">s</span></span></span></span></span> generated path.
When testing the combined system, we found that our path planning algorithms worked equally well in simulation and in hardware, but that our robot was less able to follow trajectories in hardware than in simulation. After much debugging, we narrowed down the culprit to our localization algorithm. This part of our software stack requires tuning or replacement in the future, before it can be used reliably in the final competition.
Like our robot Dizzy, we look forward to the race!</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="lessons-learned">Lessons Learned<a class="hash-link" href="#lessons-learned" title="Direct link to heading">‚Äã</a></h2><p><strong>Vedang L:</strong>
A key lesson that I learned from this lab was the advantages of getting your code working early. Being in-charge of the pure pursuit implementation on this project, , I worked diligently to finish my code before the end of the weekend. Without essential explanations I received from the TAs at the start of the project, there is no way I would have a high level understanding of the project. This left me time to optimize my code and solve issues that arose when we tried to integrate the moving parts of this project. From this experience I learned how important it is to ‚Äúown‚Äù your code. This means to take responsibility for any bugs that arise and ensure that they are solved, instead of delegating them to different people. This is far more efficient than explaining how your code works to other people, but also a more fulfilling experience.</p><p>A lesson that I learned from this lab is to always anticipate that something will go wrong. As a group we were far more disciplined in this lab than ever before, and expected that we would not be scrambling to get everything together at the end. While it was far better in this lab than others, largely because of our new team member, I learned that no amount of preparation can stop something from going wrong. Good thing there are always four other team members to help solve these last minute problems. </p><p><strong>Tiffany H:</strong>
From a technical standpoint, by implementing and debugging <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>R</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">RRT</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.13889em">RRT</span></span></span></span></span>, I learned about path-planning algorithms which will be useful to me in my research. I also developed my skills of creating readable and helpful diagrams for the slides. This lab also made me realize how important it is to start early so we could develop and have time to optimize the code as well as doing robust error analysis.</p><p>This lab was my first lab with my new teammates. As such, the main lesson I learned was how to adjust to a new and different working style and figure out which parts from my previous team I could bring in and what elements of the team culture that I should adapt to. In addition, spreading work out over a larger group than my previous three-person team came with its own challenges ‚Äì communication became more essential. However, having 4 other teammates instead of just 2 made this lab far more feasible within the time constraints. All of the team were very welcoming, which made the transition much easier.</p><p><strong>Ishita G:</strong></p><p>This week was filled with challenges! Perhaps the most pressing was the seemingly random bug in pure pursuit. As a team, we spent dozens of hours debugging that before realizing that the bulk of the issue was not in our pure pursuit code, but our localization code. In previous labs, we had always had robust working versions of all the required components, yet in this lab, we spent a lot of time debugging the older code bases. One of our team members even had the job of debugging the safety controller for much of the week since we noticed several bugs in it.</p><p>Personally, I was responsible for the <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>‚àó</mo></mrow><annotation encoding="application/x-tex">A*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal">A</span><span class="mord">‚àó</span></span></span></span></span> algorithm implementation and some simulation and hardware testing. The A* implementation went relatively smoothly until it came to converting from real life coordinates to pixel coordinates on the map. This was a tricky task, and sometimes we would be sure a method would work, yet it would not. Eventually, we got everything to work, and the algorithm performed beautifully. I really liked the way work was split this week, and I hope we continue doing this in the future.</p><p><strong>Carolina W:</strong> </p><p>This lab taught me that sometimes, old code needs to be revisited, and you should  expect to have to make more changes to your code than you might initially anticipate. After implementing the safety controller and localization code in previous labs, I didn‚Äôt expect our team would need to go back to these algorithms and tune them ‚Äì however, I spent a significant portion of this lab trying to fix our safety controller. We knew the safety controller was essential to being able to test the robot and prevent damage, and the continued bugs on the controller slowed down progress early on in the lab. In the future, I will plan for previous code breaking (in addition to the time it takes to develop new code) to avoid being surprised when I need to edit more things than I expected. </p><p>Additionally, this lab showed me the importance of staying up-to-date on what other team members are doing. It‚Äôs hard to understand every part of the lab at once, however, making sure you know the key essentials is very important. Me and two other team members were attempting to get a last-minute video of our car running the algorithms when we realized that none of us really knew how to set up the joystick when it gave us errors ‚Äì our other teammates had always dealt with that issue, but they were not around to help us debug. We eventually figured it out, but the experience was stressful, and could have been easily avoided if we‚Äôd practiced earlier.</p><p><strong>Quinn B:</strong></p><p>Taking a backseat on the coding side of things this week was very strange. I felt like I had less of a handle on the code, and overall had a worse time I think, but I now understand that this is how the other members of my team likely feel most of the time. This also seems to have been the most difficult week so far. This was the most complex combination of things we‚Äôve had to run at once, and that complexity made itself apparent when we were trying to debug our gradescope submission and trying to evaluate the combined system. The two largest takeaways from this lab, however, were the value of setting interim deadlines and the necessity of a more unified testing system. My first priority before the final competition is to set up unit tests for our algorithms and some sort of evaluation system for our integrated systems.</p><h1>Presentation</h1><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vQc-pFpdzyP9xWEbUEzPwdP8eSgiE7U0TgjtMLjCk8ZVslxAn8QpsWkunRicTplIJUsWGCj6b4OPMgl/embed?start=false&amp;loop=false&amp;delayms=3000" frameborder="0" width="960" height="569" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe><h1>Download Links</h1><p>Briefing Slides:
<a href="https://drive.google.com/uc?export=download&amp;id=13EvU1kX03CK1-2rkmZsXy8PUGGbK8Ofa" target="_blank" rel="noopener noreferrer">Download Slides</a></p><p>Report Document:
<a href="https://drive.google.com/uc?export=download&amp;id=1IIMIseqK9LHM00ok8lx5efGyg6qOozFd" target="_blank" rel="noopener noreferrer">Download Report</a></p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/rss2022-5/docs/labs/lab6.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_dcUD" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_foO9"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/website/docs/labs/lab5"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Lab 5 - Pocket Full of Poses</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/website/docs/Presentations/lab3"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Lab 3</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_cNA8 thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#path-planning" class="table-of-contents__link toc-highlight">Path Planning</a></li><li><a href="#introduction" class="table-of-contents__link toc-highlight">Introduction</a></li><li><a href="#technical-implementation" class="table-of-contents__link toc-highlight">Technical Implementation</a><ul><li><a href="#a" class="table-of-contents__link toc-highlight">A*</a></li><li><a href="#rrt" class="table-of-contents__link toc-highlight">RRT</a></li><li><a href="#pure-pursuit" class="table-of-contents__link toc-highlight">Pure Pursuit</a></li><li><a href="#pure-pursuit-driving-to-the-point" class="table-of-contents__link toc-highlight">Pure Pursuit: Driving to the Point</a></li></ul></li><li><a href="#evaluation" class="table-of-contents__link toc-highlight">Evaluation</a><ul><li><a href="#rrt-and-a-evaluation" class="table-of-contents__link toc-highlight">RRT* and A* Evaluation</a></li><li><a href="#pure-pursuit-evaluation" class="table-of-contents__link toc-highlight">Pure Pursuit Evaluation</a></li><li><a href="#hardware-performance-evaluation" class="table-of-contents__link toc-highlight">Hardware Performance Evaluation</a></li></ul></li><li><a href="#conclusion" class="table-of-contents__link toc-highlight">Conclusion</a></li><li><a href="#lessons-learned" class="table-of-contents__link toc-highlight">Lessons Learned</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Labs</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/website/docs/intro">Labs</a></li></ul></div><div class="col footer__col"><div class="footer__title">GitHub</div><ul class="footer__items"><li class="footer__item"><a href="https://github.com/rss2022-5" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright ¬© 2022 RSS Team 5, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/website/assets/js/runtime~main.05126e7d.js"></script>
<script src="/website/assets/js/main.32b19255.js"></script>
</body>
</html>